import { supabase } from '../config/supabase'
import { genAI, MODELS, estimateTokens } from './geminiService'
import { courseStructureService } from './courseStructureService'
import segmentService from './segmentService'
import { pdfTextExtractionService } from './pdfTextExtractionService'
import retrievalService from './retrievalService'
import knowledgeBaseService from './knowledgeBaseService'

/**
 * Enhanced Content Generation Service
 * AI destekli detaylƒ± eƒüitim i√ßeriƒüi √ºretimi ve y√∂netimi
 */
class EnhancedContentService {
  constructor() {
    this.model = genAI.getGenerativeModel({ 
      model: MODELS.TEXT_GENERATION 
    })
  }

  /**
   * Document i√ßin enhanced content √ºret
   * @param {string} documentId - Document ID
   * @returns {Object} Enhanced content sonucu
   */
  async generateEnhancedContent(documentId) {
    try {
      console.log(`Enhanced Content Generation ba≈ülatƒ±lƒ±yor: ${documentId}`)

      // 1. Document bilgilerini al
      const documentInfo = await this.getDocumentInfo(documentId)
      if (!documentInfo.success) {
        throw new Error(`Document bilgileri alƒ±namadƒ±: ${documentInfo.error}`)
      }

      // 2. Kurs yapƒ±sƒ±nƒ± al
      const courseStructure = await courseStructureService.getCourseStructure(documentId)
      if (!courseStructure.success) {
        throw new Error(`Kurs yapƒ±sƒ± alƒ±namadƒ±: ${courseStructure.error}`)
      }

      // 3. Her chapter i√ßin enhanced content √ºret
      const enhancedContent = await this.generateContentForChapters(documentId, courseStructure.data.courseStructure)
      if (!enhancedContent.success) {
        throw new Error(`Enhanced content √ºretilemedi: ${enhancedContent.error}`)
      }

      // 4. Enhanced content'i kaydet
      const saveResult = await this.saveEnhancedContent(documentId, enhancedContent.data)
      if (!saveResult.success) {
        throw new Error(`Enhanced content kaydedilemedi: ${saveResult.error}`)
      }

      // 5. Knowledge Base Integration - Segment'leri ve kavramlarƒ± kaydet
      const knowledgeBaseResult = await this.integrateWithKnowledgeBase(documentId, enhancedContent.data)
      if (!knowledgeBaseResult.success) {
        console.warn('Knowledge Base entegrasyonu yapƒ±lamadƒ±:', knowledgeBaseResult.error)
      }

      // 6. Kalite deƒüerlendirmesi yap
      const qualityAssessment = await this.assessContentQuality(enhancedContent.data)
      if (!qualityAssessment.success) {
        console.warn('Kalite deƒüerlendirmesi yapƒ±lamadƒ±:', qualityAssessment.error)
      }

      console.log(`Enhanced Content Generation tamamlandƒ±: ${documentId}`)
      return {
        success: true,
        documentId: documentId,
        enhancedContent: enhancedContent.data,
        qualityAssessment: qualityAssessment.success ? qualityAssessment.data : null,
        metadata: {
          generated_at: new Date().toISOString(),
          total_chapters: enhancedContent.data.chapters.length,
          total_lessons: enhancedContent.data.chapters.reduce((total, chapter) => {
            return total + (chapter.content && chapter.content.lessons ? chapter.content.lessons.length : 0)
          }, 0),
          content_types: this.getContentTypeStats(enhancedContent.data)
        }
      }

    } catch (error) {
      console.error('Enhanced Content Generation hatasƒ±:', error)
      return {
        success: false,
        error: error.message,
        documentId: documentId
      }
    }
  }

  /**
   * Chapter'lar i√ßin enhanced content √ºret
   * @param {string} documentId - Document ID
   * @param {Object} courseStructure - Kurs yapƒ±sƒ±
   * @returns {Object} Enhanced content
   */
  async generateContentForChapters(documentId, courseStructure) {
    try {
      const enhancedChapters = []

      for (const chapter of courseStructure.chapters) {
        console.log(`Chapter content √ºretiliyor: ${chapter.title}`)
        
        const chapterContent = await this.generateChapterContent(documentId, chapter, courseStructure)
        if (!chapterContent.success) {
          console.warn(`Chapter content √ºretilemedi: ${chapter.title}`, chapterContent.error)
          continue
        }

        enhancedChapters.push({
          chapterId: chapter.id,
          title: chapter.title,
          content: chapterContent.data
        })
      }

      return {
        success: true,
        data: {
          documentId: documentId,
          chapters: enhancedChapters,
          generated_at: new Date().toISOString()
        }
      }

    } catch (error) {
      console.error('Chapter content √ºretme hatasƒ±:', error)
      return {
        success: false,
        error: error.message
      }
    }
  }

  /**
   * Tek chapter i√ßin enhanced content √ºret (RAG ile zenginle≈ütirilmi≈ü context)
   * @param {string} documentId - Document ID
   * @param {Object} chapter - Chapter bilgileri
   * @param {Object} courseStructure - Kurs yapƒ±sƒ±
   * @returns {Object} Chapter content
   */
  async generateChapterContent(documentId, chapter, courseStructure) {
    try {
      console.log(`üìö Chapter i√ßin RAG context hazƒ±rlanƒ±yor: ${chapter.title}`)
      
      // Chapter'daki t√ºm lesson'larƒ±n segment ID'lerini topla
      const allSegmentIds = []
      chapter.lessons.forEach(lesson => {
        const segmentIds = lesson.segmentIds || (lesson.segmentId ? [lesson.segmentId] : [])
        allSegmentIds.push(...segmentIds)
      })
      
      // Benzersiz segment ID'leri al
      const uniqueSegmentIds = [...new Set(allSegmentIds)]
      console.log(`üìñ Chapter i√ßin ${uniqueSegmentIds.length} benzersiz segment bulundu`)
      
      // T√ºm segment i√ßeriklerini birle≈ütir (PDF extraction ile, Gemini i√ßin sadece text)
      const chapterSegmentContent = await this.getSegmentContent(uniqueSegmentIds, documentId)
      if (!chapterSegmentContent.success) {
        throw new Error(`Chapter segment i√ßerikleri alƒ±namadƒ±: ${chapterSegmentContent.error}`)
      }
      
      console.log(`üìù Chapter i√ßerik uzunluƒüu: ${chapterSegmentContent.content.length} karakter`)
      
      // RAG Context'i hazƒ±rla
      const ragContext = await this.prepareRAGContext(documentId, chapter, courseStructure, chapterSegmentContent.content)
      if (!ragContext.success) {
        console.warn(`RAG context hazƒ±rlanamadƒ±, mevcut y√∂ntemle devam ediliyor: ${ragContext.error}`)
      }
      
      // Chapter i√ßin tek seferde AI content √ºret (RAG context ile)
      const chapterContent = await this.generateChapterContentWithAI(documentId, chapter, courseStructure, chapterSegmentContent.content, ragContext.success ? ragContext.data : null)
      if (!chapterContent.success) {
        throw new Error(`Chapter content √ºretilemedi: ${chapterContent.error}`)
      }
      
      return {
        success: true,
        data: {
          chapterTitle: chapter.title,
          lessons: chapterContent.data.lessons,
          metadata: {
            segmentCount: uniqueSegmentIds.length,
            contentLength: chapterSegmentContent.content.length,
            lessonCount: chapterContent.data.lessons.length,
            ragContextUsed: ragContext.success,
            ragContextSize: ragContext.success ? ragContext.data.contextLength : 0,
            knowledgeBaseReady: true
          }
        }
      }

    } catch (error) {
      console.error('Chapter content √ºretme hatasƒ±:', error)
      return {
        success: false,
        error: error.message
      }
    }
  }

  /**
   * RAG Context hazƒ±rla (Geli≈ümi≈ü Context Building Stratejisi)
   * @param {string} documentId - Document ID
   * @param {Object} chapter - Chapter bilgileri
   * @param {Object} courseStructure - Kurs yapƒ±sƒ±
   * @param {string} segmentContent - Chapter'ƒ±n segment i√ßeriƒüi
   * @returns {Object} RAG context
   */
  async prepareRAGContext(documentId, chapter, courseStructure, segmentContent) {
    try {
      console.log(`üîç Geli≈ümi≈ü RAG context hazƒ±rlanƒ±yor: ${chapter.title}`)
      
      const contextComponents = []
      let totalContextLength = 0
      
      // 1. Cross-Chapter Context: √ñnceki chapter'larƒ±n √∂nemli bilgilerini al
      const crossChapterContext = await this.buildCrossChapterContext(documentId, chapter, courseStructure)
      if (crossChapterContext.success && crossChapterContext.data.length > 0) {
        contextComponents.push({
          type: 'cross_chapter',
          content: crossChapterContext.data,
          length: crossChapterContext.data.length,
          priority: 1 // En y√ºksek √∂ncelik
        })
        totalContextLength += crossChapterContext.data.length
        console.log(`üìö Cross-chapter context eklendi: ${crossChapterContext.data.length} karakter`)
      }
      
      // 2. Related Concepts: Benzer kavramlarƒ± vector database'den √ßek
      const relatedConceptsContext = await this.buildRelatedConceptsContext(segmentContent, documentId)
      if (relatedConceptsContext.success && relatedConceptsContext.data.length > 0) {
        contextComponents.push({
          type: 'related_concepts',
          content: relatedConceptsContext.data,
          length: relatedConceptsContext.data.length,
          priority: 2
        })
        totalContextLength += relatedConceptsContext.data.length
        console.log(`üîó Related concepts context eklendi: ${relatedConceptsContext.data.length} karakter`)
      }
      
      // 3. Semantic Search: Mevcut segment i√ßeriƒüine benzer i√ßerikleri bul
      const semanticSearchContext = await this.buildSemanticSearchContext(segmentContent, documentId)
      if (semanticSearchContext.success && semanticSearchContext.data.length > 0) {
        contextComponents.push({
          type: 'semantic_search',
          content: semanticSearchContext.data,
          length: semanticSearchContext.data.length,
          priority: 3
        })
        totalContextLength += semanticSearchContext.data.length
        console.log(`üîç Semantic search context eklendi: ${semanticSearchContext.data.length} karakter`)
      }
      
      // 4. Course Consistency: T√ºm course boyunca tutarlƒ±lƒ±k saƒüla
      const courseConsistencyContext = await this.buildCourseConsistencyContext(documentId, chapter, courseStructure)
      if (courseConsistencyContext.success && courseConsistencyContext.data.length > 0) {
        contextComponents.push({
          type: 'course_consistency',
          content: courseConsistencyContext.data,
          length: courseConsistencyContext.data.length,
          priority: 4
        })
        totalContextLength += courseConsistencyContext.data.length
        console.log(`üéØ Course consistency context eklendi: ${courseConsistencyContext.data.length} karakter`)
      }
      
      // Geli≈ümi≈ü context optimization
      const optimizedContext = this.optimizeAdvancedContext(contextComponents, 5000) // 5000 karakter limit
      
      console.log(`‚úÖ Geli≈ümi≈ü RAG context hazƒ±rlandƒ±: ${optimizedContext.length} karakter`)
      
      return {
        success: true,
        data: {
          context: optimizedContext,
          contextLength: optimizedContext.length,
          components: contextComponents.map(comp => ({
            type: comp.type,
            length: comp.length,
            priority: comp.priority
          })),
          strategy: 'advanced_context_building'
        }
      }
      
    } catch (error) {
      console.error('Geli≈ümi≈ü RAG context hazƒ±rlama hatasƒ±:', error)
      return {
        success: false,
        error: error.message
      }
    }
  }

  /**
   * Cross-Chapter Context: √ñnceki chapter'larƒ±n √∂nemli bilgilerini al
   * @param {string} documentId - Document ID
   * @param {Object} chapter - Chapter bilgileri
   * @param {Object} courseStructure - Kurs yapƒ±sƒ±
   * @returns {Object} Cross-chapter context
   */
  async buildCrossChapterContext(documentId, chapter, courseStructure) {
    try {
      // Chapter'ƒ±n sƒ±rasƒ±nƒ± bul
      const chapterIndex = courseStructure.chapters.findIndex(ch => ch.id === chapter.id)
      if (chapterIndex <= 0) {
        return {
          success: true,
          data: ''
        }
      }
      
      // √ñnceki chapter'larƒ± al (son 3 chapter - daha kapsamlƒ±)
      const previousChapters = courseStructure.chapters.slice(Math.max(0, chapterIndex - 3), chapterIndex)
      
      if (previousChapters.length === 0) {
        return {
          success: true,
          data: ''
        }
      }
      
      // Her √∂nceki chapter i√ßin detaylƒ± bilgi olu≈ütur
      const crossChapterContexts = []
      for (const prevChapter of previousChapters) {
        const chapterAnalysis = await this.analyzeChapterForCrossContext(prevChapter, documentId)
        if (chapterAnalysis.success && chapterAnalysis.data) {
          crossChapterContexts.push(chapterAnalysis.data)
        }
      }
      
      const combinedContext = crossChapterContexts.length > 0 
        ? `**CROSS-CHAPTER CONTEXT (√ñnceki ${previousChapters.length} Chapter):**\n${crossChapterContexts.join('\n\n')}\n\n`
        : ''
      
      return {
        success: true,
        data: combinedContext
      }
      
    } catch (error) {
      console.error('Cross-chapter context alma hatasƒ±:', error)
      return {
        success: false,
        error: error.message,
        data: ''
      }
    }
  }

  /**
   * Chapter'ƒ± cross-context i√ßin analiz et
   * @param {Object} chapter - Chapter bilgileri
   * @param {string} documentId - Document ID
   * @returns {Object} Chapter analizi
   */
  async analyzeChapterForCrossContext(chapter, documentId) {
    try {
      // Chapter'ƒ±n ana kavramlarƒ±nƒ± √ßƒ±kar
      const lessonTitles = chapter.lessons.map(lesson => lesson.title)
      const keyConcepts = this.extractKeyConceptsFromTitles(lessonTitles)
      
      // Chapter'ƒ±n √∂nem derecesini hesapla
      const importanceScore = this.calculateChapterImportance(chapter)
      
      // Cross-reference bilgilerini olu≈ütur
      const crossReferenceInfo = `**${chapter.title}** (√ñnem: ${importanceScore}/10):\n` +
        `- Ana Kavramlar: ${keyConcepts.join(', ')}\n` +
        `- Lesson Sayƒ±sƒ±: ${chapter.lessons.length}\n` +
        `- Bu chapter'dan sonraki chapter'larda referans verilecek √∂nemli noktalar`
      
      return {
        success: true,
        data: crossReferenceInfo
      }
      
    } catch (error) {
      console.error('Chapter analiz hatasƒ±:', error)
      return {
        success: false,
        error: error.message,
        data: ''
      }
    }
  }

  /**
   * Related Concepts: Benzer kavramlarƒ± vector database'den √ßek
   * @param {string} segmentContent - Segment i√ßeriƒüi
   * @param {string} documentId - Document ID
   * @returns {Object} Related concepts context
   */
  async buildRelatedConceptsContext(segmentContent, documentId) {
    try {
      // Segment i√ßeriƒüinden geli≈ümi≈ü anahtar kelimeler √ßƒ±kar
      const keywords = this.extractAdvancedKeywords(segmentContent)
      
      if (keywords.length === 0) {
        return {
          success: true,
          data: ''
        }
      }
      
      // Vector database'den ilgili kavramlarƒ± bul - mevcut veritabanƒ± yapƒ±sƒ±na uygun
      const relatedConcepts = await retrievalService.getRelatedConcepts(keywords.join(' '))
      if (!relatedConcepts.success || relatedConcepts.concepts.length === 0) {
        return {
          success: true,
          data: ''
        }
      }
      
      // Kavramlarƒ± √∂nem sƒ±rasƒ±na g√∂re sƒ±rala ve formatla
      const sortedConcepts = relatedConcepts.concepts
        .sort((a, b) => (b.relevance_score || 0) - (a.relevance_score || 0))
        .slice(0, 7) // ƒ∞lk 7 kavram
        .map(concept => {
          const relevance = concept.relevance_score ? ` (${Math.round(concept.relevance_score * 100)}% uyum)` : ''
          return `**${concept.name}:** ${concept.description}${relevance}`
        })
        .join('\n')
      
      const context = `**RELATED CONCEPTS (Vector Database):**\n${sortedConcepts}\n\n`
      
      return {
        success: true,
        data: context
      }
      
    } catch (error) {
      console.error('Related concepts context alma hatasƒ±:', error)
      return {
        success: false,
        error: error.message,
        data: ''
      }
    }
  }

  /**
   * Semantic Search: Mevcut segment i√ßeriƒüine benzer i√ßerikleri bul
   * @param {string} segmentContent - Segment i√ßeriƒüi
   * @param {string} documentId - Document ID
   * @returns {Object} Semantic search context
   */
  async buildSemanticSearchContext(segmentContent, documentId) {
    try {
      // Segment i√ßeriƒüinden semantic search i√ßin optimize edilmi≈ü query olu≈ütur
      const semanticQuery = this.createSemanticSearchQuery(segmentContent)
      
      // Vector database'den benzer i√ßerikleri bul
      const similarContent = await retrievalService.findRelevantContent(semanticQuery, {
        limit: 5,
        threshold: 0.5, // Daha d√º≈ü√ºk threshold - daha fazla sonu√ß
        documentId: documentId,
        contentType: 'segment_content'
      })
      
      if (!similarContent.success || similarContent.content.length === 0) {
        return {
          success: true,
          data: ''
        }
      }
      
      // Benzer i√ßerikleri semantic relevance'e g√∂re sƒ±rala ve formatla
      const semanticResults = similarContent.content
        .sort((a, b) => (b.similarity || 0) - (a.similarity || 0))
        .map(item => {
          const similarity = item.similarity ? ` (${Math.round(item.similarity * 100)}% benzerlik)` : ''
          const source = item.metadata?.chapter_title || item.metadata?.title || 'Bilinmeyen Kaynak'
          return `**${source}:** ${item.content.substring(0, 200)}...${similarity}`
        })
        .join('\n\n')
      
      const context = `**SEMANTIC SEARCH RESULTS (Vector Database):**\n${semanticResults}\n\n`
      
      return {
        success: true,
        data: context
      }
      
    } catch (error) {
      console.error('Semantic search context alma hatasƒ±:', error)
      return {
        success: false,
        error: error.message,
        data: ''
      }
    }
  }

  /**
   * Course Consistency: T√ºm course boyunca tutarlƒ±lƒ±k saƒüla
   * @param {string} documentId - Document ID
   * @param {Object} chapter - Chapter bilgileri
   * @param {Object} courseStructure - Kurs yapƒ±sƒ±
   * @returns {Object} Course consistency context
   */
  async buildCourseConsistencyContext(documentId, chapter, courseStructure) {
    try {
      // Course genelinde tutarlƒ±lƒ±k kurallarƒ±nƒ± olu≈ütur
      const consistencyRules = this.generateConsistencyRules(courseStructure, chapter)
      
      // Chapter'ƒ±n course i√ßindeki pozisyonunu analiz et
      const chapterPosition = this.analyzeChapterPosition(chapter, courseStructure)
      
      // Tutarlƒ±lƒ±k context'ini olu≈ütur
      const consistencyContext = `**COURSE CONSISTENCY RULES:**\n${consistencyRules}\n\n` +
        `**CHAPTER POSITION ANALYSIS:**\n${chapterPosition}\n\n` +
        `**CONTENT CONSISTENCY GUIDELINES:**\n` +
        `- √ñnceki chapter'larda tanƒ±mlanan kavramlarƒ± tekrar tanƒ±mlama\n` +
        `- Tutarlƒ± terminoloji kullan\n` +
        `- Course genelinde aynƒ± √∂rnek formatƒ±nƒ± koru\n` +
        `- Chapter'lar arasƒ± ge√ßi≈üleri yumu≈üak yap\n\n`
      
      return {
        success: true,
        data: consistencyContext
      }
      
    } catch (error) {
      console.error('Course consistency context alma hatasƒ±:', error)
      return {
        success: false,
        error: error.message,
        data: ''
      }
    }
  }

  /**
   * Geli≈ümi≈ü context optimization (priority-based)
   * @param {Array} contextComponents - Context bile≈üenleri (priority ile)
   * @param {number} maxLength - Maksimum uzunluk
   * @returns {string} Optimize edilmi≈ü context
   */
  optimizeAdvancedContext(contextComponents, maxLength) {
    if (contextComponents.length === 0) {
      return ''
    }
    
    // Priority'ye g√∂re sƒ±rala (d√º≈ü√ºk sayƒ± = y√ºksek √∂ncelik)
    const sortedComponents = contextComponents.sort((a, b) => a.priority - b.priority)
    
    // Toplam uzunluk kontrol et
    const totalLength = sortedComponents.reduce((sum, comp) => sum + comp.length, 0)
    
    if (totalLength <= maxLength) {
      // Limit i√ßindeyse t√ºm context'i kullan
      return sortedComponents.map(comp => comp.content).join('\n')
    }
    
    // Priority-based optimization
    let optimizedContext = ''
    let currentLength = 0
    
    for (const component of sortedComponents) {
      const remainingLength = maxLength - currentLength
      if (remainingLength <= 0) break
      
      if (component.length <= remainingLength) {
        optimizedContext += component.content + '\n'
        currentLength += component.length
      } else {
        // Component'i intelligent truncation ile kƒ±salt
        const truncatedContent = this.intelligentTruncate(component.content, remainingLength - 150)
        optimizedContext += truncatedContent + '\n'
        currentLength += truncatedContent.length
        break
      }
    }
    
    return optimizedContext.trim()
  }

  /**
   * Intelligent truncation - c√ºmle b√ºt√ºnl√ºƒü√ºn√º koru
   * @param {string} text - Metin
   * @param {number} maxLength - Maksimum uzunluk
   * @returns {string} Kƒ±saltƒ±lmƒ±≈ü metin
   */
  intelligentTruncate(text, maxLength) {
    if (text.length <= maxLength) {
      return text
    }
    
    // C√ºmle sonlarƒ±nƒ± bul
    const sentenceEndings = ['.', '!', '?', '\n\n']
    let truncatedText = text.substring(0, maxLength)
    
    // En yakƒ±n c√ºmle sonunu bul
    for (const ending of sentenceEndings) {
      const lastIndex = truncatedText.lastIndexOf(ending)
      if (lastIndex > maxLength * 0.7) { // %70'den sonra c√ºmle sonu varsa
        truncatedText = truncatedText.substring(0, lastIndex + ending.length)
        break
      }
    }
    
    return truncatedText + '...'
  }

  /**
   * Chapter √∂zeti olu≈ütur
   * @param {Object} chapter - Chapter bilgileri
   * @param {string} documentId - Document ID
   * @returns {Object} Chapter √∂zeti
   */
  async getChapterSummary(chapter, documentId) {
    try {
      // Chapter'ƒ±n lesson'larƒ±ndan basit bir √∂zet olu≈ütur
      const lessonTitles = chapter.lessons.map(lesson => lesson.title).join(', ')
      return {
        success: true,
        data: `Bu chapter ${chapter.lessons.length} lesson i√ßeriyor: ${lessonTitles}`
      }
    } catch (error) {
      return {
        success: false,
        error: error.message,
        data: ''
      }
    }
  }

  /**
   * Geli≈ümi≈ü anahtar kelime √ßƒ±karma
   * @param {string} text - Metin
   * @returns {Array} Anahtar kelimeler
   */
  extractAdvancedKeywords(text) {
    try {
      // Geli≈ümi≈ü anahtar kelime √ßƒ±karma
      const words = text.toLowerCase()
        .replace(/[^\w\s]/g, '')
        .split(/\s+/)
        .filter(word => word.length > 3)
        .filter(word => !['bu', 'bir', 've', 'ile', 'i√ßin', 'olan', 'gibi', 'kadar', 'daha', '√ßok', 'az', 'en', 'da', 'de', 'bir', 'iki', '√º√ß', 'd√∂rt', 'be≈ü'].includes(word))
      
      // En sƒ±k ge√ßen kelimeleri al
      const wordCount = {}
      words.forEach(word => {
        wordCount[word] = (wordCount[word] || 0) + 1
      })
      
      return Object.entries(wordCount)
        .sort(([,a], [,b]) => b - a)
        .slice(0, 8) // Daha fazla anahtar kelime
        .map(([word]) => word)
        
    } catch (error) {
      console.error('Geli≈ümi≈ü anahtar kelime √ßƒ±karma hatasƒ±:', error)
      return []
    }
  }

  /**
   * Lesson ba≈ülƒ±klarƒ±ndan anahtar kavramlarƒ± √ßƒ±kar
   * @param {Array} lessonTitles - Lesson ba≈ülƒ±klarƒ±
   * @returns {Array} Anahtar kavramlar
   */
  extractKeyConceptsFromTitles(lessonTitles) {
    try {
      const allWords = lessonTitles.join(' ').toLowerCase()
        .replace(/[^\w\s]/g, '')
        .split(/\s+/)
        .filter(word => word.length > 2)
        .filter(word => !['ve', 'ile', 'i√ßin', 'olan', 'gibi', 'kadar', 'daha', '√ßok', 'az', 'en', 'da', 'de'].includes(word))
      
      const wordCount = {}
      allWords.forEach(word => {
        wordCount[word] = (wordCount[word] || 0) + 1
      })
      
      return Object.entries(wordCount)
        .sort(([,a], [,b]) => b - a)
        .slice(0, 5)
        .map(([word]) => word)
        
    } catch (error) {
      console.error('Lesson ba≈ülƒ±klarƒ±ndan kavram √ßƒ±karma hatasƒ±:', error)
      return []
    }
  }

  /**
   * Chapter'ƒ±n √∂nem derecesini hesapla
   * @param {Object} chapter - Chapter bilgileri
   * @returns {number} √ñnem skoru (1-10)
   */
  calculateChapterImportance(chapter) {
    try {
      let score = 5 // Base score
      
      // Lesson sayƒ±sƒ±na g√∂re
      if (chapter.lessons.length > 5) score += 2
      else if (chapter.lessons.length > 3) score += 1
      
      // Ba≈ülƒ±k uzunluƒüuna g√∂re
      if (chapter.title.length > 30) score += 1
      
      // Ba≈ülƒ±kta √∂nemli kelimeler varsa
      const importantWords = ['temel', 'ana', '√∂nemli', 'kritik', 'merkezi', 'core', 'fundamental', 'essential']
      const hasImportantWord = importantWords.some(word => 
        chapter.title.toLowerCase().includes(word)
      )
      if (hasImportantWord) score += 1
      
      return Math.min(10, Math.max(1, score))
      
    } catch (error) {
      console.error('Chapter √∂nem hesaplama hatasƒ±:', error)
      return 5
    }
  }

  /**
   * Semantic search i√ßin optimize edilmi≈ü query olu≈ütur
   * @param {string} segmentContent - Segment i√ßeriƒüi
   * @returns {string} Semantic search query
   */
  createSemanticSearchQuery(segmentContent) {
    try {
      // ƒ∞lk 300 karakteri al ve optimize et
      const contentPreview = segmentContent.substring(0, 300)
      
      // Anahtar kelimeleri √ßƒ±kar
      const keywords = this.extractAdvancedKeywords(contentPreview)
      
      // Query'yi olu≈ütur
      const query = keywords.length > 0 
        ? `${keywords.slice(0, 3).join(' ')} ${contentPreview.substring(0, 100)}`
        : contentPreview.substring(0, 200)
      
      return query
      
    } catch (error) {
      console.error('Semantic search query olu≈üturma hatasƒ±:', error)
      return segmentContent.substring(0, 200)
    }
  }

  /**
   * Course genelinde tutarlƒ±lƒ±k kurallarƒ±nƒ± olu≈ütur
   * @param {Object} courseStructure - Kurs yapƒ±sƒ±
   * @param {Object} currentChapter - Mevcut chapter
   * @returns {string} Tutarlƒ±lƒ±k kurallarƒ±
   */
  generateConsistencyRules(courseStructure, currentChapter) {
    try {
      const totalChapters = courseStructure.chapters.length
      const currentIndex = courseStructure.chapters.findIndex(ch => ch.id === currentChapter.id)
      
      let rules = `- Course toplam ${totalChapters} chapter i√ßeriyor\n`
      rules += `- Bu chapter ${currentIndex + 1}. sƒ±rada\n`
      
      if (currentIndex > 0) {
        rules += `- √ñnceki chapter'larda tanƒ±mlanan kavramlarƒ± referans ver\n`
      }
      
      if (currentIndex < totalChapters - 1) {
        rules += `- Sonraki chapter'lara hazƒ±rlƒ±k yap\n`
      }
      
      rules += `- Tutarlƒ± terminoloji kullan\n`
      rules += `- Aynƒ± √∂rnek formatƒ±nƒ± koru\n`
      
      return rules
      
    } catch (error) {
      console.error('Tutarlƒ±lƒ±k kurallarƒ± olu≈üturma hatasƒ±:', error)
      return '- Tutarlƒ± terminoloji kullan\n- Aynƒ± √∂rnek formatƒ±nƒ± koru\n'
    }
  }

  /**
   * Chapter'ƒ±n course i√ßindeki pozisyonunu analiz et
   * @param {Object} chapter - Chapter bilgileri
   * @param {Object} courseStructure - Kurs yapƒ±sƒ±
   * @returns {string} Pozisyon analizi
   */
  analyzeChapterPosition(chapter, courseStructure) {
    try {
      const totalChapters = courseStructure.chapters.length
      const currentIndex = courseStructure.chapters.findIndex(ch => ch.id === chapter.id)
      
      let analysis = `- Chapter pozisyonu: ${currentIndex + 1}/${totalChapters}\n`
      
      if (currentIndex === 0) {
        analysis += `- Bu ilk chapter, temel kavramlarƒ± tanƒ±mla\n`
      } else if (currentIndex === totalChapters - 1) {
        analysis += `- Bu son chapter, √∂zet ve sentez yap\n`
      } else {
        analysis += `- Orta chapter, √∂nceki bilgileri kullan ve sonraki i√ßin hazƒ±rla\n`
      }
      
      analysis += `- Lesson sayƒ±sƒ±: ${chapter.lessons.length}\n`
      analysis += `- Beklenen i√ßerik derinliƒüi: ${this.getExpectedDepth(currentIndex, totalChapters)}\n`
      
      return analysis
      
    } catch (error) {
      console.error('Chapter pozisyon analizi hatasƒ±:', error)
      return '- Chapter pozisyonu analiz edilemedi\n'
    }
  }

  /**
   * Chapter sƒ±rasƒ±nƒ± al
   * @param {Object} chapter - Chapter bilgileri
   * @param {Object} courseStructure - Kurs yapƒ±sƒ±
   * @returns {string} Chapter sƒ±rasƒ±
   */
  getChapterOrder(chapter, courseStructure) {
    try {
      const chapterIndex = courseStructure.chapters.findIndex(ch => ch.id === chapter.id)
      const totalChapters = courseStructure.chapters.length
      return `${chapterIndex + 1}/${totalChapters}`
    } catch (error) {
      return 'Bilinmiyor'
    }
  }

  /**
   * √ñnceki chapter'larƒ±n √∂zetini olu≈ütur
   * @param {Object} ragContext - RAG context
   * @returns {string} √ñnceki chapter'lar √∂zeti
   */
  createPreviousChaptersSummary(ragContext) {
    if (!ragContext || !ragContext.context || !ragContext.context.includes('CROSS-CHAPTER CONTEXT')) {
      return `
    üìö √ñNCEKƒ∞ CHAPTER'LAR √ñZETƒ∞:
    Bu ilk chapter olduƒüu i√ßin √∂nceki chapter bilgisi bulunmuyor.
    Temel kavramlarƒ± tanƒ±mlayarak ba≈ülayƒ±n.
    
    `
    }
    
    // Cross-chapter context'ten √∂zet √ßƒ±kar
    const crossChapterMatch = ragContext.context.match(/CROSS-CHAPTER CONTEXT.*?LESSON'LAR:/s)
    if (crossChapterMatch) {
      const summary = crossChapterMatch[0].replace('CROSS-CHAPTER CONTEXT', '').replace('LESSON\'LAR:', '').trim()
      return `
    üìö √ñNCEKƒ∞ CHAPTER'LAR √ñZETƒ∞:
    ${summary}
    
    `
    }
    
    return `
    üìö √ñNCEKƒ∞ CHAPTER'LAR √ñZETƒ∞:
    √ñnceki chapter'larda i≈ülenen konular:
    ${ragContext.context.substring(0, 500)}...
    
    `
  }

  /**
   * ƒ∞lgili kavramlar b√∂l√ºm√ºn√º olu≈ütur
   * @param {Object} ragContext - RAG context
   * @returns {string} ƒ∞lgili kavramlar b√∂l√ºm√º
   */
  createRelatedConceptsSection(ragContext) {
    if (!ragContext || !ragContext.context || !ragContext.context.includes('RELATED CONCEPTS')) {
      return `
    üîó ƒ∞LGƒ∞Lƒ∞ KAVRAMLAR:
    Bu chapter i√ßin √∂zel kavram tanƒ±mlarƒ± hen√ºz mevcut deƒüil.
    Segment i√ßeriƒüinden √ßƒ±karƒ±lan anahtar kavramlarƒ± kullanƒ±n.
    
    `
    }
    
    // Related concepts'ten bilgi √ßƒ±kar
    const conceptsMatch = ragContext.context.match(/RELATED CONCEPTS.*?SEMANTIC SEARCH/s)
    if (conceptsMatch) {
      const concepts = conceptsMatch[0].replace('RELATED CONCEPTS', '').replace('SEMANTIC SEARCH', '').trim()
      return `
    üîó ƒ∞LGƒ∞Lƒ∞ KAVRAMLAR VE TANIMLAR:
    ${concepts}
    
    `
    }
    
    return `
    üîó ƒ∞LGƒ∞Lƒ∞ KAVRAMLAR:
    Vector database'den √ßƒ±karƒ±lan ilgili kavramlar:
    ${ragContext.context.includes('RELATED CONCEPTS') ? 'Mevcut' : 'Hen√ºz mevcut deƒüil'}
    
    `
  }

  /**
   * Tutarlƒ±lƒ±k rehberlerini olu≈ütur
   * @param {Object} ragContext - RAG context
   * @param {Object} chapter - Chapter bilgileri
   * @param {Object} courseStructure - Kurs yapƒ±sƒ±
   * @returns {string} Tutarlƒ±lƒ±k rehberleri
   */
  createConsistencyGuidelines(ragContext, chapter, courseStructure) {
    const chapterIndex = courseStructure.chapters.findIndex(ch => ch.id === chapter.id)
    const totalChapters = courseStructure.chapters.length
    
    let guidelines = `
    üéØ COURSE GENELƒ∞NDE TUTARLILIK TALƒ∞MATLARI:
    - Bu chapter ${chapterIndex + 1}/${totalChapters} sƒ±rada
    `
    
    if (chapterIndex === 0) {
      guidelines += `
    - ƒ∞lk chapter: Temel kavramlarƒ± net bir ≈üekilde tanƒ±mlayƒ±n
    - Sonraki chapter'lar i√ßin saƒülam temel olu≈üturun
    - Terminolojiyi tutarlƒ± bir ≈üekilde belirleyin
    `
    } else if (chapterIndex === totalChapters - 1) {
      guidelines += `
    - Son chapter: √ñnceki t√ºm bilgileri sentezleyin
    - Course genelinde √∂ƒürenilenleri birle≈ütirin
    - Kapsamlƒ± √∂zet ve deƒüerlendirme yapƒ±n
    `
    } else {
      guidelines += `
    - Orta chapter: √ñnceki bilgileri kullanƒ±n ve geni≈ületin
    - Sonraki chapter'lara hazƒ±rlƒ±k yapƒ±n
    - Tutarlƒ± terminoloji kullanƒ±n
    `
    }
    
    if (ragContext && ragContext.context && ragContext.context.includes('COURSE CONSISTENCY RULES')) {
      const consistencyMatch = ragContext.context.match(/COURSE CONSISTENCY RULES.*?CHAPTER POSITION/s)
      if (consistencyMatch) {
        const rules = consistencyMatch[0].replace('COURSE CONSISTENCY RULES', '').replace('CHAPTER POSITION', '').trim()
        guidelines += `
    ${rules}
    `
      }
    }
    
    guidelines += `
    - √ñnceki chapter'larda tanƒ±mlanan kavramlarƒ± tekrar tanƒ±mlamayƒ±n
    - Tutarlƒ± √∂rnek formatƒ± kullanƒ±n
    - Chapter'lar arasƒ± ge√ßi≈üleri yumu≈üak yapƒ±n
    `
    
    return guidelines
  }

  /**
   * Geli≈ümi≈ü talimatlarƒ± olu≈ütur
   * @param {Object} ragContext - RAG context
   * @param {Object} chapter - Chapter bilgileri
   * @param {Object} courseStructure - Kurs yapƒ±sƒ±
   * @returns {string} Geli≈ümi≈ü talimatlar
   */
  createEnhancedInstructions(ragContext, chapter, courseStructure) {
    const chapterIndex = courseStructure.chapters.findIndex(ch => ch.id === chapter.id)
    const totalChapters = courseStructure.chapters.length
    
    let instructions = `
    üöÄ GELƒ∞≈ûMƒ∞≈û √úRETƒ∞M TALƒ∞MATLARI:
    `
    
    if (ragContext && ragContext.context && ragContext.context.length > 0) {
      instructions += `
    ‚úÖ RAG CONTEXT KULLANIMI:
    - Yukarƒ±daki RAG context'ini aktif olarak kullanƒ±n
    - √ñnceki chapter'larla baƒülantƒ±lar kurun
    - Tutarlƒ± terminoloji ve yakla≈üƒ±m sergileyin
    - Cross-reference'lar ekleyin
    `
    } else {
      instructions += `
    ‚ÑπÔ∏è RAG CONTEXT DURUMU:
    - Bu chapter i√ßin RAG context hen√ºz mevcut deƒüil
    - Segment i√ßeriƒüine odaklanƒ±n
    - Temel kavramlarƒ± net bir ≈üekilde tanƒ±mlayƒ±n
    `
    }
    
    instructions += `
    üìù ƒ∞√áERƒ∞K √úRETƒ∞M STRATEJƒ∞Sƒ∞:
    - Her lesson i√ßin ayrƒ± ayrƒ± detaylƒ± i√ßerik olu≈üturun
    - Chapter b√ºt√ºnl√ºƒü√ºn√º koruyun
    - Pratik ve uygulanabilir √∂rnekler verin
    - √ñƒürenci odaklƒ± a√ßƒ±klamalar yapƒ±n
    `
    
    if (chapterIndex > 0) {
      instructions += `
    üîó √ñNCEKƒ∞ CHAPTER BAƒûLANTILARI:
    - √ñnceki chapter'larda ge√ßen kavramlarƒ± referans verin
    - "Daha √∂nce √∂ƒürendiƒüimiz..." gibi ge√ßi≈üler kullanƒ±n
    - Bilgiyi geni≈ületin, tekrar etmeyin
    `
    }
    
    if (chapterIndex < totalChapters - 1) {
      instructions += `
    üîÆ SONRAKƒ∞ CHAPTER HAZIRLIƒûI:
    - Sonraki chapter'lara hazƒ±rlƒ±k yapƒ±n
    - "Bir sonraki b√∂l√ºmde g√∂receƒüimiz..." gibi ipu√ßlarƒ± verin
    - √ñƒürenciyi motive edin
    `
    }
    
    instructions += `
    üéØ KALƒ∞TE STANDARTLARI:
    - A√ßƒ±klayƒ±cƒ± metinler minimum 400 karakter olsun
    - En az 6 madde listesi ekleyin
    - Ger√ßek hayat √∂rnekleri verin
    - √ñzetler minimum 200 karakter olsun
    - Cross-reference'lar ekleyin (eƒüer uygunsa)
    `
    
    return instructions
  }

  /**
   * Knowledge Base Integration - Segment'leri ve kavramlarƒ± kaydet
   * @param {string} documentId - Document ID
   * @param {Object} enhancedContent - Enhanced content
   * @returns {Object} Integration result
   */
  async integrateWithKnowledgeBase(documentId, enhancedContent) {
    try {
      console.log(`üóÑÔ∏è Knowledge Base entegrasyonu ba≈ülatƒ±lƒ±yor: ${documentId}`)
      
      const integrationResults = {
        segmentsStored: 0,
        conceptsExtracted: 0,
        relationshipsCreated: 0,
        errors: []
      }
      
      // Her chapter i√ßin knowledge base entegrasyonu
      for (const chapter of enhancedContent.chapters) {
        console.log(`üìö Chapter knowledge base entegrasyonu: ${chapter.title}`)
        
        // 1. Segment'leri knowledge base'e kaydet
        const segmentResult = await this.storeChapterSegments(documentId, chapter)
        if (segmentResult.success) {
          integrationResults.segmentsStored += segmentResult.data.storedCount
        } else {
          integrationResults.errors.push(`Segment storage error: ${segmentResult.error}`)
        }
        
        // 2. Kavramlarƒ± √ßƒ±kar ve kaydet
        const conceptResult = await this.extractAndStoreConcepts(documentId, chapter)
        if (conceptResult.success) {
          integrationResults.conceptsExtracted += conceptResult.data.extractedCount
        } else {
          integrationResults.errors.push(`Concept extraction error: ${conceptResult.error}`)
        }
        
        // 3. ƒ∞li≈ükileri olu≈ütur
        const relationshipResult = await this.createConceptRelationships(documentId, chapter)
        if (relationshipResult.success) {
          integrationResults.relationshipsCreated += relationshipResult.data.relationshipCount
        } else {
          integrationResults.errors.push(`Relationship creation error: ${relationshipResult.error}`)
        }
      }
      
      console.log(`‚úÖ Knowledge Base entegrasyonu tamamlandƒ±: ${integrationResults.segmentsStored} segment, ${integrationResults.conceptsExtracted} kavram, ${integrationResults.relationshipsCreated} ili≈üki`)
      
      return {
        success: true,
        data: integrationResults
      }
      
    } catch (error) {
      console.error('Knowledge Base entegrasyonu hatasƒ±:', error)
      return {
        success: false,
        error: error.message
      }
    }
  }

  /**
   * Chapter segment'lerini knowledge base'e kaydet
   * @param {string} documentId - Document ID
   * @param {Object} chapter - Chapter bilgileri
   * @returns {Object} Storage result
   */
  async storeChapterSegments(documentId, chapter) {
    try {
      let storedCount = 0
      
      // Her lesson i√ßin segment'leri kaydet
      for (const lesson of chapter.content.lessons) {
        const lessonContent = this.combineLessonContent(lesson)
        
        // Knowledge base'e kaydet
        const storeResult = await knowledgeBaseService.storeSegment(
          documentId,
          lesson.lessonId, // lesson ID'yi segment_id olarak kullan
          lessonContent,
          {
            chapter_title: chapter.title,
            lesson_title: lesson.title,
            content_type: 'lesson_content',
            lessonId: lesson.lessonId, // metadata i√ßinde de sakla
            metadata: {
              chapterId: chapter.chapterId,
              lessonId: lesson.lessonId,
              contentLength: lessonContent.length
            }
          }
        )
        
        if (storeResult.success) {
          storedCount++
        }
      }
      
      return {
        success: true,
        data: {
          storedCount: storedCount,
          chapterTitle: chapter.title
        }
      }
      
    } catch (error) {
      console.error('Segment storage hatasƒ±:', error)
      return {
        success: false,
        error: error.message
      }
    }
  }

  /**
   * Lesson i√ßeriƒüini birle≈ütir
   * @param {Object} lesson - Lesson bilgileri
   * @returns {string} Birle≈ütirilmi≈ü i√ßerik
   */
  combineLessonContent(lesson) {
    const content = lesson.content
    let combinedContent = ''
    
    // A√ßƒ±klayƒ±cƒ± metin
    if (content.explanatory_text) {
      combinedContent += content.explanatory_text + '\n\n'
    }
    
    // Anahtar noktalar
    if (content.key_points && content.key_points.length > 0) {
      combinedContent += 'Anahtar Noktalar:\n' + content.key_points.join('\n') + '\n\n'
    }
    
    // Tablolar
    if (content.tables && content.tables.length > 0) {
      content.tables.forEach((table, index) => {
        combinedContent += `Tablo ${index + 1}: ${table.title}\n`
        if (table.headers) {
          combinedContent += table.headers.join(' | ') + '\n'
        }
        if (table.rows) {
          table.rows.forEach(row => {
            combinedContent += row.join(' | ') + '\n'
          })
        }
        combinedContent += '\n'
      })
    }
    
    // Kod √∂rnekleri
    if (content.code_examples && content.code_examples.length > 0) {
      content.code_examples.forEach((example, index) => {
        combinedContent += `Kod √ñrneƒüi ${index + 1}: ${example.title}\n`
        combinedContent += `${example.language}\n${example.code}\n\n`
      })
    }
    
    // Pratik √∂rnekler
    if (content.practical_examples && content.practical_examples.length > 0) {
      content.practical_examples.forEach((example, index) => {
        combinedContent += `Pratik √ñrnek ${index + 1}: ${example.title}\n`
        combinedContent += `${example.description}\n\n`
      })
    }
    
    // Cross-references
    if (content.cross_references && content.cross_references.length > 0) {
      combinedContent += 'ƒ∞lgili Konular:\n'
      content.cross_references.forEach(ref => {
        combinedContent += `- ${ref.chapter}: ${ref.reference}\n`
      })
      combinedContent += '\n'
    }
    
    // √ñzet
    if (content.summary) {
      combinedContent += `√ñzet: ${content.summary}\n\n`
    }
    
    return combinedContent.trim()
  }

  /**
   * Kavramlarƒ± √ßƒ±kar ve kaydet
   * @param {string} documentId - Document ID
   * @param {Object} chapter - Chapter bilgileri
   * @returns {Object} Extraction result
   */
  async extractAndStoreConcepts(documentId, chapter) {
    try {
      let extractedCount = 0
      
      // Her lesson'dan kavramlarƒ± √ßƒ±kar
      for (const lesson of chapter.content.lessons) {
        const lessonContent = this.combineLessonContent(lesson)
        
        // Anahtar kelimeleri √ßƒ±kar
        const keywords = this.extractAdvancedKeywords(lessonContent)
        
        // Her anahtar kelime i√ßin concept olu≈ütur
        for (const keyword of keywords.slice(0, 5)) { // ƒ∞lk 5 kavram
          const conceptDescription = this.generateConceptDescription(keyword, lessonContent)
          
          // Concept'i kaydet
          const storeResult = await knowledgeBaseService.storeConcept(
            keyword,
            conceptDescription,
            {
              document_id: documentId,
              chapter_title: chapter.title,
              lesson_title: lesson.title,
              relevance_score: this.calculateConceptRelevance(keyword, lessonContent)
            }
          )
          
          if (storeResult.success) {
            extractedCount++
          }
        }
      }
      
      return {
        success: true,
        data: {
          extractedCount: extractedCount,
          chapterTitle: chapter.title
        }
      }
      
    } catch (error) {
      console.error('Concept extraction hatasƒ±:', error)
      return {
        success: false,
        error: error.message
      }
    }
  }

  /**
   * Kavram a√ßƒ±klamasƒ± olu≈ütur
   * @param {string} keyword - Anahtar kelime
   * @param {string} content - ƒ∞√ßerik
   * @returns {string} Kavram a√ßƒ±klamasƒ±
   */
  generateConceptDescription(keyword, content) {
    try {
      // ƒ∞√ßerikte kavramƒ±n ge√ßtiƒüi c√ºmleleri bul
      const sentences = content.split(/[.!?]+/).filter(sentence => 
        sentence.toLowerCase().includes(keyword.toLowerCase())
      )
      
      if (sentences.length > 0) {
        // ƒ∞lk c√ºmleyi al ve kƒ±salt (100 karakter sƒ±nƒ±rƒ±)
        const firstSentence = sentences[0].trim()
        return firstSentence.length > 95 
          ? firstSentence.substring(0, 95) + '...'
          : firstSentence
      }
      
      // C√ºmle bulunamazsa basit a√ßƒ±klama
      return `${keyword} ile ilgili √∂nemli bir kavram.`
      
    } catch (error) {
      return `${keyword} ile ilgili √∂nemli bir kavram.`
    }
  }

  /**
   * Kavram √∂nem skorunu hesapla
   * @param {string} keyword - Anahtar kelime
   * @param {string} content - ƒ∞√ßerik
   * @returns {number} √ñnem skoru (0-1)
   */
  calculateConceptRelevance(keyword, content) {
    try {
      const keywordLower = keyword.toLowerCase()
      const contentLower = content.toLowerCase()
      
      // Ge√ßme sayƒ±sƒ±nƒ± hesapla
      const occurrences = (contentLower.match(new RegExp(keywordLower, 'g')) || []).length
      
      // ƒ∞√ßerik uzunluƒüuna g√∂re normalize et
      const contentLength = contentLower.length
      const frequency = occurrences / contentLength
      
      // Skoru 0-1 arasƒ±nda sƒ±nƒ±rla
      return Math.min(1, Math.max(0, frequency * 1000))
      
    } catch (error) {
      return 0.5 // Default skor
    }
  }

  /**
   * Kavram ili≈ükilerini olu≈ütur
   * @param {string} documentId - Document ID
   * @param {Object} chapter - Chapter bilgileri
   * @returns {Object} Relationship result
   */
  async createConceptRelationships(documentId, chapter) {
    try {
      let relationshipCount = 0
      
      // Chapter'daki t√ºm kavramlarƒ± topla
      const chapterConcepts = []
      
      for (const lesson of chapter.content.lessons) {
        const lessonContent = this.combineLessonContent(lesson)
        const keywords = this.extractAdvancedKeywords(lessonContent)
        chapterConcepts.push(...keywords.slice(0, 3)) // Her lesson'dan 3 kavram
      }
      
      // Benzersiz kavramlarƒ± al
      const uniqueConcepts = [...new Set(chapterConcepts)]
      
      // Kavramlar arasƒ± ili≈ükiler olu≈ütur
      for (let i = 0; i < uniqueConcepts.length; i++) {
        for (let j = i + 1; j < uniqueConcepts.length; j++) {
          const concept1 = uniqueConcepts[i]
          const concept2 = uniqueConcepts[j]
          
          // ƒ∞li≈üki skorunu hesapla
          const relationshipScore = this.calculateRelationshipScore(concept1, concept2, chapter)
          
          if (relationshipScore > 0.3) { // Minimum skor
            // ƒ∞li≈ükiyi kaydet
            const storeResult = await knowledgeBaseService.storeConceptRelationship(
              concept1,
              concept2,
              relationshipScore,
              {
                document_id: documentId,
                chapter_title: chapter.title,
                relationship_type: 'semantic_similarity'
              }
            )
            
            if (storeResult.success) {
              relationshipCount++
            }
          }
        }
      }
      
      return {
        success: true,
        data: {
          relationshipCount: relationshipCount,
          chapterTitle: chapter.title
        }
      }
      
    } catch (error) {
      console.error('Relationship creation hatasƒ±:', error)
      return {
        success: false,
        error: error.message
      }
    }
  }

  /**
   * ƒ∞ki kavram arasƒ±ndaki ili≈üki skorunu hesapla
   * @param {string} concept1 - ƒ∞lk kavram
   * @param {string} concept2 - ƒ∞kinci kavram
   * @param {Object} chapter - Chapter bilgileri
   * @returns {number} ƒ∞li≈üki skoru (0-1)
   */
  calculateRelationshipScore(concept1, concept2, chapter) {
    try {
      let totalScore = 0
      let lessonCount = 0
      
      // Her lesson'da kavramlarƒ±n birlikte ge√ßme durumunu kontrol et
      for (const lesson of chapter.content.lessons) {
        const lessonContent = this.combineLessonContent(lesson)
        const contentLower = lessonContent.toLowerCase()
        
        const concept1Present = contentLower.includes(concept1.toLowerCase())
        const concept2Present = contentLower.includes(concept2.toLowerCase())
        
        if (concept1Present && concept2Present) {
          // Aynƒ± lesson'da ge√ßiyorlarsa y√ºksek skor
          totalScore += 0.8
        } else if (concept1Present || concept2Present) {
          // Sadece biri ge√ßiyorsa d√º≈ü√ºk skor
          totalScore += 0.2
        }
        
        lessonCount++
      }
      
      // Ortalama skoru hesapla
      return lessonCount > 0 ? totalScore / lessonCount : 0
      
    } catch (error) {
      return 0.5 // Default skor
    }
  }

  /**
   * Beklenen i√ßerik derinliƒüini hesapla
   * @param {number} chapterIndex - Chapter index'i
   * @param {number} totalChapters - Toplam chapter sayƒ±sƒ±
   * @returns {string} Beklenen derinlik
   */
  getExpectedDepth(chapterIndex, totalChapters) {
    if (chapterIndex === 0) return 'Temel (Giri≈ü)'
    if (chapterIndex === totalChapters - 1) return 'ƒ∞leri (Sentez)'
    if (chapterIndex < totalChapters * 0.3) return 'Orta (Geli≈ütirme)'
    if (chapterIndex < totalChapters * 0.7) return 'ƒ∞leri (Uygulama)'
    return 'Uzman (Derinle≈ütirme)'
  }

  /**
   * Chapter i√ßin AI ile t√ºm lesson'larƒ± tek seferde √ºret
   * @param {string} documentId - Document ID
   * @param {Object} chapter - Chapter bilgileri
   * @param {Object} courseStructure - Kurs yapƒ±sƒ±
   * @param {string} segmentContent - Birle≈ütirilmi≈ü segment i√ßeriƒüi (sadece text)
   * @param {Object} ragContext - RAG context (opsiyonel)
   * @returns {Object} Chapter content
   */
  async generateChapterContentWithAI(documentId, chapter, courseStructure, segmentContent, ragContext = null) {
    try {
      console.log(`ü§ñ Chapter i√ßin AI content √ºretimi ba≈ülatƒ±lƒ±yor: ${chapter.title}`)
      
      // Chapter i√ßin optimize edilmi≈ü prompt olu≈ütur (RAG context ile)
      const prompt = this.createChapterPrompt(chapter, courseStructure, segmentContent, ragContext)
      
      console.log(`üì§ AI'ya g√∂nderilen prompt uzunluƒüu: ${prompt.length} karakter`)
      if (ragContext) {
        console.log(`üîç RAG context kullanƒ±ldƒ±: ${ragContext.contextLength} karakter`)
      }
      
      // Rate limiting ile AI content √ºret
      const aiResponse = await this.generateContentWithRetry(prompt)
      if (!aiResponse.success) {
        throw new Error(`AI content √ºretilemedi: ${aiResponse.error}`)
      }
      
      console.log(`üì• AI'dan gelen response uzunluƒüu: ${aiResponse.data.length} karakter`)
      
      // Content'i parse et ve yapƒ±landƒ±r
      const structuredContent = this.parseAndStructureChapterContent(aiResponse.data, chapter)
      if (!structuredContent.success) {
        throw new Error(`Chapter content yapƒ±landƒ±rƒ±lamadƒ±: ${structuredContent.error}`)
      }
      
      return {
        success: true,
        data: {
          chapterTitle: chapter.title,
          lessons: structuredContent.data.lessons,
          metadata: {
            generated_at: new Date().toISOString(),
            lessonCount: structuredContent.data.lessons.length,
            contentLength: JSON.stringify(structuredContent.data).length,
            ragContextUsed: !!ragContext,
            ragContextSize: ragContext ? ragContext.contextLength : 0
          }
        }
      }

    } catch (error) {
      console.error('Chapter AI content √ºretme hatasƒ±:', error)
      return {
        success: false,
        error: error.message
      }
    }
  }

  /**
   * Chapter i√ßin AI prompt olu≈ütur (Geli≈ümi≈ü Prompt Engineering)
   * @param {Object} chapter - Chapter bilgileri
   * @param {Object} courseStructure - Kurs yapƒ±sƒ±
   * @param {string} segmentContent - Birle≈ütirilmi≈ü segment i√ßeriƒüi (sadece text)
   * @param {Object} ragContext - RAG context (opsiyonel)
   * @returns {string} AI prompt
   */
  createChapterPrompt(chapter, courseStructure, segmentContent, ragContext = null) {
    // Geli≈ümi≈ü prompt sections
    const previousChaptersSummary = this.createPreviousChaptersSummary(ragContext)
    const relatedConceptsSection = this.createRelatedConceptsSection(ragContext)
    const consistencyGuidelines = this.createConsistencyGuidelines(ragContext, chapter, courseStructure)
    const enhancedInstructions = this.createEnhancedInstructions(ragContext, chapter, courseStructure)
    
    return `
    ========================================
    GELƒ∞≈ûMƒ∞≈û Eƒûƒ∞Tƒ∞M ƒ∞√áERƒ∞ƒûƒ∞ √úRETƒ∞M PROMPT'U
    ========================================
    
    üìö KURS Bƒ∞LGƒ∞LERƒ∞:
    Kurs Adƒ±: ${courseStructure.title}
    Chapter: ${chapter.title}
    Lesson Sayƒ±sƒ±: ${chapter.lessons.length}
    Chapter Sƒ±rasƒ±: ${this.getChapterOrder(chapter, courseStructure)}
    
    ${previousChaptersSummary}
    
    ${relatedConceptsSection}
    
    ${consistencyGuidelines}
    
    üìñ LESSON'LAR:
    ${chapter.lessons.map((lesson, index) => `${index + 1}. ${lesson.title}`).join('\n')}
    
    üìÑ SEGMENT ƒ∞√áERƒ∞ƒûƒ∞ (PDF'den √ßƒ±karƒ±lan ger√ßek metin, tablolar ve g√∂rsel a√ßƒ±klamalarƒ±):
    ${segmentContent || 'Segment i√ßeriƒüi bulunamadƒ±.'}
    
    ${enhancedInstructions}
    
    üéØ ƒ∞√áERƒ∞K T√úRLERƒ∞ (Her lesson i√ßin zorunlu):
    1. **A√ßƒ±klayƒ±cƒ± Metin** - Konuyu detaylƒ± a√ßƒ±klayan paragraflar (minimum 400 karakter)
    2. **Madde Listeleri** - √ñnemli noktalarƒ± listeleyen maddeler (en az 6 madde)
    3. **Tablo** - Kar≈üƒ±la≈ütƒ±rma veya √∂zet tablolarƒ± (eƒüer uygunsa)
    4. **Kod Bloklarƒ±** - √ñrnek kodlar (eƒüer uygunsa)
    5. **Pratik √ñrnekler** - Ger√ßek hayat √∂rnekleri (en az 3 √∂rnek)
    6. **√ñzet** - Ders √∂zeti (minimum 200 karakter)
    7. **Cross-References** - √ñnceki chapter'lara referanslar (eƒüer varsa)
    
    üìã JSON FORMATI:
    {
      "lessons": [
        {
          "lessonId": "lesson-1-1",
          "title": "Lesson Ba≈ülƒ±ƒüƒ±",
          "content": {
            "explanatory_text": "Detaylƒ± a√ßƒ±klayƒ±cƒ± metin...",
            "key_points": ["Madde 1", "Madde 2", "Madde 3", "Madde 4", "Madde 5", "Madde 6"],
            "tables": [
              {
                "title": "Tablo ba≈ülƒ±ƒüƒ±",
                "headers": ["S√ºtun 1", "S√ºtun 2"],
                "rows": [["Veri 1", "Veri 2"], ["Veri 3", "Veri 4"]]
              }
            ],
            "code_examples": [
              {
                "language": "javascript",
                "title": "√ñrnek kod ba≈ülƒ±ƒüƒ±",
                "code": "console.log('Hello World');"
              }
            ],
            "practical_examples": [
              {
                "title": "√ñrnek ba≈ülƒ±ƒüƒ±",
                "description": "Detaylƒ± √∂rnek a√ßƒ±klamasƒ±"
              }
            ],
            "cross_references": [
              {
                "chapter": "√ñnceki Chapter Adƒ±",
                "reference": "ƒ∞lgili kavram veya konu"
              }
            ],
            "summary": "Detaylƒ± ders √∂zeti..."
          }
        }
      ]
    }
    
    ‚ö†Ô∏è √ñNEMLƒ∞: Sadece JSON d√∂nd√ºr, ba≈üka a√ßƒ±klama ekleme.
    `
  }

  /**
   * Chapter AI response'unu parse et ve yapƒ±landƒ±r (Geli≈ümi≈ü)
   * @param {string} aiResponse - AI response
   * @param {Object} chapter - Chapter bilgileri
   * @returns {Object} Structured chapter content
   */
  parseAndStructureChapterContent(aiResponse, chapter) {
    try {
      // AI response'u temizle - markdown code blocks'larƒ± kaldƒ±r
      let cleanedResponse = aiResponse.trim()
      
      // ```json ve ``` i≈üaretlerini kaldƒ±r
      if (cleanedResponse.startsWith('```json')) {
        cleanedResponse = cleanedResponse.substring(7)
      } else if (cleanedResponse.startsWith('```')) {
        cleanedResponse = cleanedResponse.substring(3)
      }
      
      if (cleanedResponse.endsWith('```')) {
        cleanedResponse = cleanedResponse.substring(0, cleanedResponse.length - 3)
      }
      
      // JSON parse et
      const parsedContent = JSON.parse(cleanedResponse.trim())
      
      // Content'i doƒürula ve yapƒ±landƒ±r
      if (!parsedContent.lessons || !Array.isArray(parsedContent.lessons)) {
        throw new Error('AI response\'da lessons array bulunamadƒ±')
      }
      
      const structuredLessons = parsedContent.lessons.map(lessonData => {
        return {
          lessonId: lessonData.lessonId || lessonData.title,
          title: lessonData.title,
          content: {
            explanatory_text: lessonData.content?.explanatory_text || '',
            key_points: Array.isArray(lessonData.content?.key_points) ? lessonData.content.key_points : [],
            tables: Array.isArray(lessonData.content?.tables) ? lessonData.content.tables : [],
            code_examples: Array.isArray(lessonData.content?.code_examples) ? lessonData.content.code_examples : [],
            practical_examples: Array.isArray(lessonData.content?.practical_examples) ? lessonData.content.practical_examples : [],
            cross_references: Array.isArray(lessonData.content?.cross_references) ? lessonData.content.cross_references : [],
            summary: lessonData.content?.summary || ''
          }
        }
      })

      return {
        success: true,
        data: {
          lessons: structuredLessons
        }
      }

    } catch (error) {
      console.error('Chapter content parse hatasƒ±:', error)
      return {
        success: false,
        error: `JSON parse hatasƒ±: ${error.message}`
      }
    }
  }

  /**
   * AI ile content √ºret (Rate limiting ile retry)
   * @param {string} prompt - AI prompt
   * @returns {Object} AI response
   */
  async generateContentWithRetry(prompt) {
    const maxRetries = 3
    const baseDelay = 5000 // 5 saniye
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        console.log(`ü§ñ AI isteƒüi g√∂nderiliyor (Deneme ${attempt}/${maxRetries})`)
        
        const result = await this.model.generateContent(prompt)
        const response = await result.response
        const text = response.text()
        
        console.log(`‚úÖ AI isteƒüi ba≈üarƒ±lƒ± (Deneme ${attempt})`)
        
        return {
          success: true,
          data: text
        }

      } catch (error) {
        console.error(`‚ùå AI isteƒüi ba≈üarƒ±sƒ±z (Deneme ${attempt}):`, error.message)
        
        // Rate limit hatasƒ± ise bekle ve tekrar dene
        if (error.message.includes('429') || error.message.includes('quota')) {
          if (attempt < maxRetries) {
            const delay = baseDelay * attempt // 5s, 10s, 15s
            console.log(`‚è≥ Rate limit a≈üƒ±ldƒ±. ${delay/1000} saniye bekleniyor...`)
            await new Promise(resolve => setTimeout(resolve, delay))
            continue
          }
        }
        
        // Son deneme veya ba≈üka hata
        if (attempt === maxRetries) {
          return {
            success: false,
            error: error.message
          }
        }
      }
    }
  }

  /**
   * Tek lesson i√ßin enhanced content √ºret (Artƒ±k kullanƒ±lmƒ±yor)
   * @param {string} documentId - Document ID
   * @param {Object} lesson - Lesson bilgileri
   * @param {Object} chapter - Chapter bilgileri
   * @param {Object} courseStructure - Kurs yapƒ±sƒ±
   * @returns {Object} Lesson content
   */
  async generateLessonContent(documentId, lesson, chapter, courseStructure) {
    try {
      // Debug: Lesson bilgilerini g√∂ster
      console.log('üîç LESSON DEBUG:', {
        lessonTitle: lesson.title,
        lessonId: lesson.id,
        segmentIds: lesson.segmentIds,
        hasSegmentIds: !!lesson.segmentIds && lesson.segmentIds.length > 0
      })

      // Segment i√ßeriklerini al
      const segmentContent = await this.getSegmentContent(lesson.segmentIds || [], documentId)
      
      // √ñƒürenme hedeflerini al
      const learningObjectives = await this.getLearningObjectives(documentId, chapter.id)
      
      // √ñnceki lesson'larƒ± al
      const previousLessons = await this.getPreviousLessons(documentId, chapter.id, lesson.order || 0)

      // Zenginle≈ütirilmi≈ü context ile AI prompt olu≈ütur
      const prompt = this.createLessonPrompt(lesson, chapter, courseStructure, {
        segmentContent: segmentContent.content,
        learningObjectives: learningObjectives.objectives,
        previousLessons: previousLessons.lessons
      })
      
      // Debug: Prompt'u g√∂ster
      console.log('ü§ñ GEMINI PROMPT:', {
        lessonTitle: lesson.title,
        segmentContentLength: segmentContent.content.length,
        learningObjectivesCount: learningObjectives.objectives.length,
        previousLessonsCount: previousLessons.lessons.length,
        promptPreview: prompt.substring(0, 500) + '...'
      })
      
      // AI ile content √ºret
      const aiResponse = await this.generateContentWithAI(prompt)
      if (!aiResponse.success) {
        throw new Error(`AI content √ºretilemedi: ${aiResponse.error}`)
      }

      // Debug: AI response'unu g√∂ster
      console.log('ü§ñ GEMINI RESPONSE:', {
        lessonTitle: lesson.title,
        responseLength: aiResponse.data.length,
        responsePreview: aiResponse.data.substring(0, 300) + '...'
      })

      // Content'i parse et ve yapƒ±landƒ±r
      const structuredContent = this.parseAndStructureContent(aiResponse.data, lesson)
      if (!structuredContent.success) {
        throw new Error(`Content yapƒ±landƒ±rƒ±lamadƒ±: ${structuredContent.error}`)
      }

      return {
        success: true,
        data: {
          lessonTitle: lesson.title,
          content: structuredContent.data,
          metadata: {
            generated_at: new Date().toISOString(),
            content_length: JSON.stringify(structuredContent.data).length,
            content_types: this.getContentTypes(structuredContent.data),
            segmentCount: segmentContent.segments.length,
            hasLearningObjectives: learningObjectives.objectives.length > 0,
            previousLessonsCount: previousLessons.lessons.length
          }
        }
      }

    } catch (error) {
      console.error('Lesson content √ºretme hatasƒ±:', error)
      return {
        success: false,
        error: error.message
      }
    }
  }

  /**
   * Lesson i√ßin AI prompt olu≈ütur
   * @param {Object} lesson - Lesson bilgileri
   * @param {Object} chapter - Chapter bilgileri
   * @param {Object} courseStructure - Kurs yapƒ±sƒ±
   * @param {Object} context - Zenginle≈ütirilmi≈ü context
   * @returns {string} AI prompt
   */
  createLessonPrompt(lesson, chapter, courseStructure, context = {}) {
    const { segmentContent = '', learningObjectives = [], previousLessons = [] } = context

    return `
    A≈üaƒüƒ±daki lesson i√ßin detaylƒ± eƒüitim i√ßeriƒüi √ºret:
    
    KURS Bƒ∞LGƒ∞LERƒ∞:
    Kurs: ${courseStructure.title}
    Chapter: ${chapter.title}
    Lesson: ${lesson.title}
    
    √ñƒûRENME HEDEFLERƒ∞:
    ${learningObjectives.length > 0 ? learningObjectives.map(obj => `- ${obj}`).join('\n') : 'Bu lesson i√ßin √∂zel hedef belirtilmemi≈ü.'}
    
    √ñNCEKƒ∞ LESSON BAƒûLANTILARI:
    ${previousLessons.length > 0 ? previousLessons.map(prev => `- ${prev.title}`).join('\n') : 'Bu ilk lesson.'}
    
    SEGMENT ƒ∞√áERƒ∞ƒûƒ∞ (PDF'den √ßƒ±karƒ±lan ger√ßek metin):
    ${segmentContent || 'Segment i√ßeriƒüi bulunamadƒ±.'}
    
    TALƒ∞MATLAR:
    Yukarƒ±daki segment i√ßeriƒüini kullanarak, √∂ƒürenme hedeflerine uygun ve √∂nceki lesson'larla baƒülantƒ±lƒ± detaylƒ± eƒüitim i√ßeriƒüi √ºret.
    
    ƒ∞√ßerik t√ºrleri:
    1. **A√ßƒ±klayƒ±cƒ± Metin** - Konuyu detaylƒ± a√ßƒ±klayan paragraflar (minimum 300 karakter)
    2. **Madde Listeleri** - √ñnemli noktalarƒ± listeleyen maddeler (en az 5 madde)
    3. **Tablo** - Kar≈üƒ±la≈ütƒ±rma veya √∂zet tablolarƒ± (eƒüer uygunsa)
    4. **Kod Bloklarƒ±** - √ñrnek kodlar (eƒüer uygunsa)
    5. **√ñrnekler** - Pratik √∂rnekler (en az 2 √∂rnek)
    6. **√ñzet** - Ders √∂zeti (minimum 150 karakter)
    
    JSON formatƒ±nda d√∂nd√ºr:
    {
      "explanatory_text": "A√ßƒ±klayƒ±cƒ± metin...",
      "key_points": ["Madde 1", "Madde 2", "Madde 3", "Madde 4", "Madde 5"],
      "tables": [
        {
          "title": "Tablo ba≈ülƒ±ƒüƒ±",
          "headers": ["S√ºtun 1", "S√ºtun 2"],
          "rows": [["Veri 1", "Veri 2"], ["Veri 3", "Veri 4"]]
        }
      ],
      "code_examples": [
        {
          "language": "javascript",
          "title": "√ñrnek kod ba≈ülƒ±ƒüƒ±",
          "code": "console.log('Hello World');"
        }
      ],
      "practical_examples": [
        {
          "title": "√ñrnek ba≈ülƒ±ƒüƒ±",
          "description": "√ñrnek a√ßƒ±klamasƒ±"
        }
      ],
      "summary": "Ders √∂zeti..."
    }
    
    Sadece JSON d√∂nd√ºr, ba≈üka a√ßƒ±klama ekleme.
    `
  }

  /**
   * AI ile content √ºret
   * @param {string} prompt - AI prompt
   * @returns {Object} AI response
   */
  async generateContentWithAI(prompt) {
    try {
      const result = await this.model.generateContent(prompt)
      const response = await result.response
      const text = response.text()
      
      return {
        success: true,
        data: text
      }

    } catch (error) {
      console.error('AI content √ºretme hatasƒ±:', error)
      return {
        success: false,
        error: error.message
      }
    }
  }

  /**
   * AI response'u parse et ve yapƒ±landƒ±r
   * @param {string} aiResponse - AI response
   * @param {Object} lesson - Lesson bilgileri
   * @returns {Object} Structured content
   */
  parseAndStructureContent(aiResponse, lesson) {
    try {
      // AI response'u temizle - markdown code blocks'larƒ± kaldƒ±r
      let cleanedResponse = aiResponse.trim()
      
      // ```json ve ``` i≈üaretlerini kaldƒ±r
      if (cleanedResponse.startsWith('```json')) {
        cleanedResponse = cleanedResponse.substring(7)
      } else if (cleanedResponse.startsWith('```')) {
        cleanedResponse = cleanedResponse.substring(3)
      }
      
      if (cleanedResponse.endsWith('```')) {
        cleanedResponse = cleanedResponse.substring(0, cleanedResponse.length - 3)
      }
      
      // JSON parse et
      const parsedContent = JSON.parse(cleanedResponse.trim())
      
      // Content'i doƒürula ve yapƒ±landƒ±r
      const structuredContent = {
        explanatory_text: parsedContent.explanatory_text || '',
        key_points: Array.isArray(parsedContent.key_points) ? parsedContent.key_points : [],
        tables: Array.isArray(parsedContent.tables) ? parsedContent.tables : [],
        code_examples: Array.isArray(parsedContent.code_examples) ? parsedContent.code_examples : [],
        practical_examples: Array.isArray(parsedContent.practical_examples) ? parsedContent.practical_examples : [],
        summary: parsedContent.summary || ''
      }

      return {
        success: true,
        data: structuredContent
      }

    } catch (error) {
      console.error('Content parse hatasƒ±:', error)
      return {
        success: false,
        error: `JSON parse hatasƒ±: ${error.message}`
      }
    }
  }

  /**
   * Enhanced content'i kaydet
   * @param {string} documentId - Document ID
   * @param {Object} enhancedContent - Enhanced content
   * @returns {Object} Save result
   */
  async saveEnhancedContent(documentId, enhancedContent) {
    try {
      const { data, error } = await supabase
        .from('documents')
        .update({
          enhanced_content: enhancedContent,
          enhanced_content_generated_at: new Date().toISOString()
        })
        .eq('id', documentId)
        .select()

      if (error) {
        throw new Error(`Enhanced content kaydedilemedi: ${error.message}`)
      }

      return {
        success: true,
        data: data[0]
      }

    } catch (error) {
      console.error('Enhanced content kaydetme hatasƒ±:', error)
      return {
        success: false,
        error: error.message
      }
    }
  }

  /**
   * Enhanced content'i al
   * @param {string} documentId - Document ID
   * @returns {Object} Enhanced content
   */
  async getEnhancedContent(documentId) {
    try {
      const { data, error } = await supabase
        .from('documents')
        .select('enhanced_content, enhanced_content_generated_at')
        .eq('id', documentId)
        .single()

      if (error) {
        throw new Error(`Enhanced content alƒ±namadƒ±: ${error.message}`)
      }

      return {
        success: true,
        data: {
          enhanced_content: data.enhanced_content,
          generated_at: data.enhanced_content_generated_at
        }
      }

    } catch (error) {
      console.error('Enhanced content alma hatasƒ±:', error)
      return {
        success: false,
        error: error.message
      }
    }
  }

  /**
   * ƒ∞√ßerik kalitesi deƒüerlendirmesi
   * @param {Object} enhancedContent - Enhanced content
   * @returns {Object} Quality assessment
   */
  async assessContentQuality(enhancedContent) {
    try {
      const assessment = {
        overall_score: 0,
        chapter_scores: [],
        issues: [],
        recommendations: []
      }

      let totalScore = 0
      let chapterCount = 0

      for (const chapter of enhancedContent.chapters) {
        const chapterScore = this.assessChapterQuality(chapter)
        assessment.chapter_scores.push({
          chapterId: chapter.chapterId,
          title: chapter.title,
          score: chapterScore.score,
          issues: chapterScore.issues
        })

        totalScore += chapterScore.score
        chapterCount++
      }

      assessment.overall_score = chapterCount > 0 ? Math.round(totalScore / chapterCount) : 0

      // Genel √∂neriler
      if (assessment.overall_score < 70) {
        assessment.recommendations.push("ƒ∞√ßerik kalitesi d√º≈ü√ºk. AI prompt'larƒ± iyile≈ütirilmeli.");
      }

      return {
        success: true,
        data: assessment
      }

    } catch (error) {
      console.error('Kalite deƒüerlendirmesi hatasƒ±:', error)
      return {
        success: false,
        error: error.message
      }
    }
  }

  /**
   * Chapter kalitesi deƒüerlendirmesi
   * @param {Object} chapter - Chapter content
   * @returns {Object} Chapter quality assessment
   */
  assessChapterQuality(chapter) {
    const issues = []
    let score = 100

    // Null checks
    if (!chapter || !chapter.content) {
      issues.push('Chapter content bulunamadƒ±')
      return {
        score: 0,
        issues: issues
      }
    }

    if (!chapter.content.lessons || !Array.isArray(chapter.content.lessons)) {
      issues.push('Chapter lessons bulunamadƒ± veya ge√ßersiz format')
      return {
        score: 0,
        issues: issues
      }
    }

    // Lesson sayƒ±sƒ± kontrol√º
    if (chapter.content.lessons.length === 0) {
      issues.push('Hi√ß lesson i√ßeriƒüi yok')
      score -= 30
    }

    // Her lesson i√ßin kalite kontrol√º
    for (const lesson of chapter.content.lessons) {
      if (!lesson || !lesson.content) {
        issues.push(`${lesson?.title || 'Unknown'}: Lesson content bulunamadƒ±`)
        score -= 10
        continue
      }

      if (!lesson.content.explanatory_text || lesson.content.explanatory_text.length < 100) {
        issues.push(`${lesson.title}: A√ßƒ±klayƒ±cƒ± metin √ßok kƒ±sa`)
        score -= 5
      }

      if (!lesson.content.key_points || lesson.content.key_points.length === 0) {
        issues.push(`${lesson.title}: Anahtar noktalar eksik`)
        score -= 5
      }

      if (!lesson.content.summary || lesson.content.summary.length < 50) {
        issues.push(`${lesson.title}: √ñzet eksik veya √ßok kƒ±sa`)
        score -= 5
      }
    }

    return {
      score: Math.max(0, score),
      issues: issues
    }
  }

  /**
   * Content type istatistikleri
   * @param {Object} enhancedContent - Enhanced content
   * @returns {Object} Content type stats
   */
  getContentTypeStats(enhancedContent) {
    const stats = {
      total_chapters: enhancedContent.chapters.length,
      total_lessons: 0,
      content_types: {
        explanatory_text: 0,
        key_points: 0,
        tables: 0,
        code_examples: 0,
        practical_examples: 0,
        summaries: 0
      }
    }

    for (const chapter of enhancedContent.chapters) {
      if (chapter.content && chapter.content.lessons && Array.isArray(chapter.content.lessons)) {
        stats.total_lessons += chapter.content.lessons.length

        for (const lesson of chapter.content.lessons) {
          if (lesson && lesson.content) {
            if (lesson.content.explanatory_text) stats.content_types.explanatory_text++
            if (lesson.content.key_points && lesson.content.key_points.length > 0) stats.content_types.key_points++
            if (lesson.content.tables && lesson.content.tables.length > 0) stats.content_types.tables++
            if (lesson.content.code_examples && lesson.content.code_examples.length > 0) stats.content_types.code_examples++
            if (lesson.content.practical_examples && lesson.content.practical_examples.length > 0) stats.content_types.practical_examples++
            if (lesson.content.summary) stats.content_types.summaries++
          }
        }
      }
    }

    return stats
  }

  /**
   * Content types al
   * @param {Object} content - Content
   * @returns {Array} Content types
   */
  getContentTypes(content) {
    const types = []
    if (content.explanatory_text) types.push('explanatory_text')
    if (content.key_points.length > 0) types.push('key_points')
    if (content.tables.length > 0) types.push('tables')
    if (content.code_examples.length > 0) types.push('code_examples')
    if (content.practical_examples.length > 0) types.push('practical_examples')
    if (content.summary) types.push('summary')
    return types
  }

  /**
   * Segment i√ßeriklerini al (PDF extraction ile text ve g√∂rsel ayrƒ±≈ütƒ±rma, Gemini i√ßin sadece text)
   * @param {Array} segmentIds - Segment ID'leri
   * @param {string} documentId - Document ID (opsiyonel, segment'lerden alƒ±nacak)
   * @returns {Object} Segment i√ßerikleri
   */
  async getSegmentContent(segmentIds, documentId = null) {
    try {
      if (!segmentIds || !Array.isArray(segmentIds) || segmentIds.length === 0) {
        return {
          success: true,
          content: '',
          segments: []
        }
      }

      // √ñnce veritabanƒ±ndan segment'leri kontrol et
      const { data: segments, error } = await supabase
        .from('segments')
        .select('id, seg_no, title, content, p_start, p_end, extracted_content, document_id')
        .in('id', segmentIds)
        .order('seg_no', { ascending: true })

      if (error) {
        throw new Error(`Segment i√ßerikleri alƒ±namadƒ±: ${error.message}`)
      }

      // Eƒüer segment'lerde content yoksa, PDF'den √ßƒ±kar
      const segmentsWithoutContent = segments.filter(segment => !segment.content)
      
      if (segmentsWithoutContent.length > 0) {
        console.log(`${segmentsWithoutContent.length} segment i√ßin PDF extraction gerekli`)
        
        // Document ID'yi belirle (parametre veya segment'ten)
        const targetDocumentId = documentId || segments[0]?.document_id
        
        if (!targetDocumentId) {
          throw new Error('Document ID bulunamadƒ±. Segment\'lerde document_id yok veya parametre ge√ßilmedi.')
        }
        
        console.log(`üìÑ PDF extraction i√ßin document ID: ${targetDocumentId}`)
        
        // PDF extraction yap (text + g√∂rsel + tablo)
        const extractionResult = await pdfTextExtractionService.extractSegmentContent(
          targetDocumentId,
          segmentsWithoutContent.map(s => s.id)
        )
        
        if (extractionResult.success) {
          // √áƒ±karƒ±lan i√ßerikleri segment'lere ekle
          for (const extractedSegment of extractionResult.data.segments) {
            const segmentIndex = segments.findIndex(s => s.id === extractedSegment.segmentId)
            if (segmentIndex !== -1) {
              segments[segmentIndex].content = extractedSegment.content.text
              segments[segmentIndex].extracted_content = extractedSegment.content
            }
          }
        }
      }

      // Segment i√ßeriklerini birle≈ütir (Gemini i√ßin sadece text)
      const combinedContent = segments
        .map(segment => {
          let content = `## ${segment.title}\n`
          
          // Ana metin (her zaman ekle)
          if (segment.content) {
            content += segment.content
          } else if (segment.extracted_content && segment.extracted_content.text) {
            content += segment.extracted_content.text
          } else {
            content += 'ƒ∞√ßerik bulunamadƒ±.'
          }
          
          // Tablolar varsa text olarak ekle (Gemini i√ßin)
          if (segment.extracted_content && segment.extracted_content.tables && segment.extracted_content.tables.length > 0) {
            content += '\n\n### Tablolar\n\n'
            segment.extracted_content.tables.forEach((table, index) => {
              content += `**Tablo ${index + 1} (Sayfa ${table.pageNum}):**\n\n`
              
              if (table.headers && table.headers.length > 0) {
                content += `| ${table.headers.join(' | ')} |\n`
                content += `| ${table.headers.map(() => '---').join(' | ')} |\n`
              }
              
              if (table.rows && table.rows.length > 0) {
                table.rows.forEach(row => {
                  content += `| ${row.join(' | ')} |\n`
                })
              }
              
              content += '\n'
            })
          }
          
          // G√∂rseller varsa sadece a√ßƒ±klama ekle (base64 g√∂nderme)
          if (segment.extracted_content && segment.extracted_content.images && segment.extracted_content.images.length > 0) {
            content += '\n\n### G√∂rseller\n\n'
            segment.extracted_content.images.forEach((image, index) => {
              if (image.exists) {
                content += `**G√∂rsel ${index + 1}:** ${image.imageName} (${image.width}x${image.height})\n\n`
              }
            })
          }
          
          return content
        })
        .join('\n\n')

      return {
        success: true,
        content: combinedContent,
        segments: segments || []
      }

    } catch (error) {
      console.error('Segment i√ßerik alma hatasƒ±:', error)
      return {
        success: false,
        error: error.message,
        content: '',
        segments: []
      }
    }
  }

  /**
   * √ñƒürenme hedeflerini al
   * @param {string} documentId - Document ID
   * @param {string} chapterId - Chapter ID
   * @returns {Object} √ñƒürenme hedefleri
   */
  async getLearningObjectives(documentId, chapterId) {
    try {
      // Course structure'dan chapter'ƒ± bul
      const courseStructure = await courseStructureService.getCourseStructure(documentId)
      if (!courseStructure.success) {
        return {
          success: false,
          objectives: []
        }
      }

      const chapter = courseStructure.data.courseStructure.chapters.find(ch => ch.id === chapterId)
      if (!chapter || !chapter.learningObjectives) {
        return {
          success: true,
          objectives: []
        }
      }

      return {
        success: true,
        objectives: chapter.learningObjectives
      }

    } catch (error) {
      console.error('√ñƒürenme hedefleri alma hatasƒ±:', error)
      return {
        success: false,
        error: error.message,
        objectives: []
      }
    }
  }

    /**
   * √ñnceki lesson'larƒ± al
   * @param {string} documentId - Document ID
   * @param {string} chapterId - Chapter ID
   * @param {number} currentLessonOrder - Mevcut lesson sƒ±rasƒ±
   * @returns {Object} √ñnceki lesson'lar
   */
  async getPreviousLessons(documentId, chapterId, currentLessonOrder) {
    try {
      // Course structure'dan chapter'ƒ± bul
      const courseStructure = await courseStructureService.getCourseStructure(documentId)
      if (!courseStructure.success) {
        return {
          success: false,
          lessons: []
        }
      }

      const chapter = courseStructure.data.courseStructure.chapters.find(ch => ch.id === chapterId)
      if (!chapter || !chapter.lessons) {
        return {
          success: true,
          lessons: []
        }
      }

      // Mevcut lesson'dan √∂nceki lesson'larƒ± al
      const previousLessons = chapter.lessons
        .filter(lesson => lesson.order < currentLessonOrder)
        .slice(-3) // Son 3 lesson'ƒ± al

      return {
        success: true,
        lessons: previousLessons
      }

    } catch (error) {
      console.error("√ñnceki lesson'lar alma hatasƒ±:", error);
      return {
        success: false,
        error: error.message,
        lessons: []
      };
    }
  }
    
  

  /**
   * Document bilgilerini al
   * @param {string} documentId - Document ID
   * @returns {Object} Document info
   */
  async getDocumentInfo(documentId) {
    try {
      const { data, error } = await supabase
        .from('documents')
        .select('*')
        .eq('id', documentId)
        .single();

      if (error) {
        throw new Error(`Document alƒ±namadƒ±: ${error.message}`);
      }

      return {
        success: true,
        data: data
      };
    } catch (error) {
      console.error('Document bilgileri alma hatasƒ±:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Enhanced Content Generation testini √ßalƒ±≈ütƒ±rƒ±r
   * @param {string} documentId - Document ID
   * @returns {Object} Test sonucu
   */
  async testEnhancedContentGeneration(documentId) {
    try {
      console.log(`Enhanced Content Generation test ba≈ülatƒ±lƒ±yor: ${documentId}`);

      const result = await this.generateEnhancedContent(documentId);

      if (result.success) {
        console.log('‚úÖ Enhanced Content Generation test ba≈üarƒ±lƒ±');
        console.log('üìä Metadata:', result.metadata);

        if (result.qualityAssessment) {
          console.log('üìà Kalite Deƒüerlendirmesi:', result.qualityAssessment.overall_score);
        }
      } else {
        console.error('‚ùå Enhanced Content Generation test ba≈üarƒ±sƒ±z:', result.error);
      }

      return result;
    } catch (error) {
      console.error('Enhanced Content Generation test hatasƒ±:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

}
// Service instance'ƒ± olu≈ütur ve export et
export const enhancedContentService = new EnhancedContentService(); 